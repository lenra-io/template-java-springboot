package io.lenra.app.scripts;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class GenerateClasses {

  public static void main(String[] args) {
    generateClasses();
  }

  private static void generateClasses() {
    Path libDir = Paths.get("src", "lib");
    Path baseComponentsDir = Paths.get(libDir.toString(), "gen", "components");
    Path componentsImplDir = Paths.get(libDir.toString(), "components");
    Path componentsFile = Paths.get(componentsImplDir.toString(), "index.java");

    try {
      generateClasses(baseComponentsDir, componentsImplDir, componentsFile);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private static void generateClasses(Path baseComponentsDir, Path componentsImplDir, Path componentsFile)
      throws IOException {
    Path schemaPath = Paths.get("api", "responses", "view.schema.json");
    String schemaContent = Files.readString(schemaPath);
    
    // Parse JSON schema
    // ...

    List<String> componentList = new ArrayList<>();
    // Add components to the list
    // ...

    // Generate not existing classes
    List<String> componentsExports = new ArrayList<>();
    boolean componentsFileChanged = false;

    for (String ref : componentList) {
      String comp = ref.substring(ref.lastIndexOf("/") + 1, ref.lastIndexOf("."));
      // Check if the class exists
      // ...

      Path baseClassPath = Paths.get(baseComponentsDir.toString(), comp + ".base.ts");
      System.out.println("Generating " + baseClassPath + " file for " + schema.getTitle());
      Files.writeString(baseClassPath, generateBaseClass(schema));

      // Check if the file corresponding to the schema exists
      Path classPath = Paths.get(componentsImplDir.toString(), comp + ".ts");

      if (!Files.exists(classPath)) {
        // Creates the file
        System.out.println("Generating " + classPath + " file for " + schema.getTitle());
        Files.writeString(classPath, generateImplClass(schema, comp + ".base"));
      }

      // Check if the file is imported in the main components file
      String importComponent = "export * from './" + comp + ".js';";
      if (!componentsExports.contains(importComponent)) {
        System.out.println("Adding import for " + classPath);
        componentsExports.add(importComponent);
        componentsFileChanged = true;
      }
    }

    if (componentsFileChanged) {
      System.out.println("Updating " + componentsFile);
      componentsExports.sort(null);
      componentsExports.add(0, "// This file is auto-generated by generate-classes.js. Do not edit it.");
      Files.write(componentsFile, componentsExports);
    }
  }

  private static String generateImplClass(Schema schema, String from) {
    String title = schema.getTitle();
    Map<String, Property> properties = schema.getProperties();
    List<String> required = schema.getRequired();
    List<String> requiredNoType = new ArrayList<>();

    for (String key : required) {
      if (!key.equals("_type")) {
        requiredNoType.add(key);
      }
    }

    StringBuilder sb = new StringBuilder();
    sb.append("// This file is auto-generated by generate-classes.js. Do not edit it.\n\n");
    sb.append("import { I").append(title).append(", ").append(title).append("BaseImpl } from \"../gen/components/")
        .append(from).append(".js\";\n\n");
    sb.append("export { I").append(title).append(" };\n\n");
    sb.append("export function ").append(title).append("(");
    for (int i = 0; i < requiredNoType.size(); i++) {
      String key = requiredNoType.get(i);
      sb.append(key).append(": I").append(title).append("['").append(key).append("']");
      if (i < requiredNoType.size() - 1) {
        sb.append(", ");
      }
    }
    sb.append("): ").append(title).append("Impl {\n");
    sb.append("  return new ").append(title).append("Impl({\n");
    sb.append("    _type: \"").append(properties.get("_type").getConst()).append("\",\n");
    for (String key : requiredNoType) {
      sb.append("    ").append(key).append(": ").append(key).append(",\n");
    }
    sb.append("  });\n");
    sb.append("}\n\n");
    sb.append("export class ").append(title).append("Impl extends ").append(title).append("BaseImpl {\n");
    sb.append("  // Add here custom implementations\n");
    sb.append("}\n");

    return sb.toString();
  }

  private static String generateBaseClass(Schema schema) {
    String title = schema.getTitle();
    Map<String, Property> properties = schema.getProperties();
    List<String> required = schema.getRequired();
    List<String> propertiesNotRequired = new ArrayList<>();

    for (Map.Entry<String, Property> entry : properties.entrySet()) {
      String key = entry.getKey();
      if (!required.contains(key)) {
        propertiesNotRequired.add(key);
      }
    }

    StringBuilder sb = new StringBuilder();
    sb.append("// This file is auto-generated by generate-classes.js but it can be edited\n\n");
    sb.append("import { ").append(title).append(" as I").append(title).append(" } from \"../response.js\";\n");
    sb.append("import { ListenerName } from \"../names.js\";\n");
    sb.append("import { Component } from \"../../components/component.js\";\n\n");
    sb.append("export { I").append(title).append(" };\n\n");
    sb.append("public class ").append(title).append("BaseImpl extends Component<I").append(title).append("> {\n");
    for (String key : propertiesNotRequired) {
      Property property = properties.get(key);
      List<String> jsdocLines = new ArrayList<>();
      StringBuilder jsdoc = new StringBuilder();
      if (property.getDescription() != null) {
        jsdocLines.add(property.getDescription());
      }
      if (property.getDeprecated() != null) {
        jsdocLines.add("@deprecated " + property.getDeprecatedComment());
      }
      if (!jsdocLines.isEmpty()) {
        jsdoc.append("/**\n");
        for (String line : jsdocLines) {
          jsdoc.append(" * ").append(line).append("\n");
        }
        jsdoc.append(" */\n");
      }
      if (key.matches("^on[A-Z].*")) {
        sb.append(jsdoc).append("public void ").append(key)
            .append("(ListenerName listener, Map<String, Object> props) {\n");
        sb.append("    return this.setListener(\"").append(key).append("\", listener, props);\n");
        sb.append("}\n\n");
      } else {
        sb.append(jsdoc).append("public void ").append(key).append("(I").append(title).append(" ").append(key)
            .append(") {\n");
        sb.append("    this.model.").append(key).append(" = ").append(key).append(";\n");
        sb.append("    return this;\n");
        sb.append("}\n\n");
      }
    }
    sb.append("}\n");
  }
}
