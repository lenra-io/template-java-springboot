// package io.lenra.app.scripts;

// import java.io.IOException;
// import java.nio.file.Files;
// import java.nio.file.Path;
// import java.nio.file.Paths;
// import java.util.ArrayList;
// import java.util.List;
// import java.util.Map;
// import java.util.Set;

// import com.google.gson.Gson;
// import com.google.gson.JsonArray;
// import com.google.gson.JsonElement;
// import com.google.gson.JsonObject;
// import com.google.gson.JsonParser;

// public class GenerateClasses {

//   public static void main(String[] args) {
//     generateClasses();
//   }

//   private static void generateClasses() {
//     Path baseComponentsDir = Paths.get("gen", "components");
//     Path componentsImplDir = Paths.get("components");
//     Path componentsFile = Paths.get(componentsImplDir.toString(), "index.java");

//     try {
//       generateClasses(baseComponentsDir, componentsImplDir, componentsFile);
//     } catch (IOException e) {
//       e.printStackTrace();
//     }
//   }

//   private static void generateClasses(Path baseComponentsDir, Path componentsImplDir, Path componentsFile)
//       throws IOException {
//     Path schemaPath = Paths.get("api", "responses", "view.schema.json");
//     String schemaContent = Files.readString(schemaPath);

//     JsonObject mainSchema = JsonParser.parseString(schemaContent).getAsJsonObject();

//     List<String> componentList = new ArrayList<>();
//     // Add components to the list
//     // definitions > components.lenra > oneOf
//     JsonArray lenraComponents = mainSchema.getAsJsonObject("definitions").getAsJsonObject("components.lenra")
//         .getAsJsonArray("oneOf");

//     for (int i = 0; i < lenraComponents.size(); i++) {
//       JsonObject component = lenraComponents.get(i).getAsJsonObject();
//       String ref = component.getAsJsonPrimitive("$ref").getAsString();
//       componentList.add(ref);
//     }

//     // definitions > components.json > oneOf
//     JsonArray jsonComponents = mainSchema.getAsJsonObject("definitions").getAsJsonObject("components.json")
//         .getAsJsonArray("oneOf");

//     for (int i = 0; i < jsonComponents.size(); i++) {
//       JsonObject component = jsonComponents.get(i).getAsJsonObject();
//       String ref = component.getAsJsonPrimitive("$ref").getAsString();
//       componentList.add(ref);
//     }

//     // Generate not existing classes
//     List<String> componentsExports = new ArrayList<>();
//     boolean componentsFileChanged = false;

//     for (String ref : componentList) {
//       String comp = ref.substring(ref.lastIndexOf("."), ref.length() - 1);

//       // Check if the class exists
//       String[] splitted = ref.replace("/^#\\/?/", "").split("/");

//       JsonObject schema = mainSchema.getAsJsonObject(splitted[0]);
//       for (int i = 1; i < splitted.length; i++) {
//         schema = schema.getAsJsonObject(splitted[i]);
//       }

//       Path baseClassPath = Paths.get(baseComponentsDir.toString(), comp + ".base.java");
//       System.out.println("Generating " + baseClassPath + " file for " + schema.get("title").getAsString());
//       Files.writeString(baseClassPath, generateBaseClass(schema));

//       // Check if the file corresponding to the schema exists
//       Path classPath = Paths.get(componentsImplDir.toString(), comp + ".java");

//       if (!Files.exists(classPath)) {
//         // Creates the file
//         System.out.println("Generating " + classPath + " file for " + schema.get("title").getAsString());
//         Files.writeString(classPath, generateImplClass(schema, comp + ".base"));
//       }

//       // Check if the file is imported in the main components file
//       String importComponent = "export * from './" + comp + ".js';";
//       if (!componentsExports.contains(importComponent)) {
//         System.out.println("Adding import for " + classPath);
//         componentsExports.add(importComponent);
//         componentsFileChanged = true;
//       }
//     }

//     if (componentsFileChanged) {
//       System.out.println("Updating " + componentsFile);
//       componentsExports.sort(null);
//       componentsExports.add(0, "// This file is auto-generated by GenerateClasses.java. Do not edit it.");
//       Files.write(componentsFile, componentsExports);
//     }
//   }

//   private static String generateImplClass(JsonObject schema, String from) {
//     String title = schema.get("title").getAsString();
//     JsonObject properties = schema.getAsJsonObject("properties");
//     JsonArray required = schema.getAsJsonArray("required");
//     List<String> requiredNoType = new ArrayList<>();

//     for (JsonElement key : required) {
//       String keyStr = key.getAsString();
//       if (!keyStr.equals("_type")) {
//         requiredNoType.add(keyStr);
//       }
//     }

//     StringBuilder sb = new StringBuilder();
//     sb.append("// This file is auto-generated by GenerateClasses.java. Do not edit it.\n\n");
//     sb.append(String.format("import { I%s, %sBaseImpl } from \"../gen/components/%s.js\";\n\n", title, title, from));
//     sb.append(String.format("export { I%s };\n\n", title));
//     sb.append("export function ").append(title).append("(");
//     for (int i = 0; i < requiredNoType.size(); i++) {
//       String key = requiredNoType.get(i);
//       sb.append(key).append(": I").append(title).append("['").append(key).append("']");
//       if (i < requiredNoType.size() - 1) {
//         sb.append(", ");
//       }
//     }
//     sb.append("): ").append(title).append("Impl {\n");
//     sb.append("  return new ").append(title).append("Impl({\n");
//     sb.append("    _type: \"").append(properties.get("_type").getConst()).append("\",\n");
//     for (String key : requiredNoType) {
//       sb.append("    ").append(key).append(": ").append(key).append(",\n");
//     }
//     sb.append("  });\n");
//     sb.append("}\n\n");
//     sb.append("export class ").append(title).append("Impl extends ").append(title).append("BaseImpl {\n");
//     sb.append("  // Add here custom implementations\n");
//     sb.append("}\n");

//     return sb.toString();
//   }

//   private static String generateBaseClass(JsonObject schema) {
//     String title = schema.get("title").getAsString();
//     JsonObject properties = schema.getAsJsonObject("properties");
//     JsonArray required = schema.getAsJsonArray("required");
//     List<String> propertiesNotRequired = new ArrayList<>();

//     // loop through properties and add the one that are not required.
//     Set<String> propertiesKeys = properties.keySet();

//     for (String key : propertiesKeys) {
//       boolean found = false;

//       for(int i = 0; i < required.size(); i++) {  
//         if(required.get(i).getAsString().equals(key)) found = true;
//       }

//       if (!found) {
//         propertiesNotRequired.add(key);
//       }
//     }

//     StringBuilder sb = new StringBuilder();
//     sb.append("// This file is auto-generated by generate-classes.js but it can be edited\n\n");
//     sb.append("import { ").append(title).append(" as I").append(title).append(" } from \"../response.js\";\n");
//     sb.append("import { ListenerName } from \"../names.js\";\n");
//     sb.append("import { Component } from \"../../components/component.js\";\n\n");
//     sb.append("export { I").append(title).append(" };\n\n");
//     sb.append("public class ").append(title).append("BaseImpl extends Component<I").append(title).append("> {\n");
//     for (String key : propertiesNotRequired) {
//       Property property = properties.get(key);
//       List<String> jsdocLines = new ArrayList<>();
//       StringBuilder jsdoc = new StringBuilder();
//       if (property.getDescription() != null) {
//         jsdocLines.add(property.getDescription());
//       }
//       if (property.getDeprecated() != null) {
//         jsdocLines.add("@deprecated " + property.getDeprecatedComment());
//       }
//       if (!jsdocLines.isEmpty()) {
//         jsdoc.append("/**\n");
//         for (String line : jsdocLines) {
//           jsdoc.append(" * ").append(line).append("\n");
//         }
//         jsdoc.append(" */\n");
//       }
//       if (key.matches("^on[A-Z].*")) {
//         sb.append(jsdoc).append("public void ").append(key)
//             .append("(ListenerName listener, Map<String, Object> props) {\n");
//         sb.append("    return this.setListener(\"").append(key).append("\", listener, props);\n");
//         sb.append("}\n\n");
//       } else {
//         sb.append(jsdoc).append("public void ").append(key).append("(I").append(title).append(" ").append(key)
//             .append(") {\n");
//         sb.append("    this.model.").append(key).append(" = ").append(key).append(";\n");
//         sb.append("    return this;\n");
//         sb.append("}\n\n");
//       }
//     }
//     sb.append("}\n");
//   }
// }
